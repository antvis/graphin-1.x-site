{"componentChunkName":"component---node-modules-antv-gatsby-theme-antv-0-11-7-antv-gatsby-theme-antv-site-templates-example-tsx","path":"/zh/examples/advanced/find-connections","result":{"data":{"site":{"siteMetadata":{"title":"Graphin","githubUrl":"https://github.com/antvis/graphin","examples":[{"slug":"render","icon":null,"title":{"zh":"数据渲染","en":"render"}},{"slug":"layout","icon":null,"title":{"zh":"内置布局","en":"layout"}},{"slug":"shape","icon":null,"title":{"zh":"节点与边","en":"shape"}},{"slug":"components","icon":null,"title":{"zh":"分析组件","en":"components"}},{"slug":"advanced","icon":null,"title":{"zh":"高级功能","en":"advanced"}},{"slug":"case","icon":null,"title":{"zh":"分析案例","en":"case"}}],"playground":{"container":null,"playgroundDidMount":null,"playgroundWillUnmount":null,"dependencies":null,"htmlCodeTemplate":null}},"pathPrefix":""},"allMarkdownRemark":{"edges":[{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Graphin 支持渲染节点：节点本身无任何布局信息(x,y)"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/render/simple"},"frontmatter":{"title":"数据无布局信息","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"render/simple/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1: General Toolbar, which provides analysis operations. Built-in redo (Operation History), canvas scaling, full screen, node focus, canvas snapshot download and other functions."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2: Custom Toolbar, which provides direction to control horizontal or vertical display. We can use the render function to expand the Toolbar. By using render, we can add custom functions to the Toolbar, such as layout switching."}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/components/toolbar"},"frontmatter":{"title":"Toolbar","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"components/toolbar/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Graphin 中内置了 5 种基础布局，分别为"},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"circle"}]},{"type":"text","value":" , "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"concentirc"}]},{"type":"text","value":" , "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"grid"}]},{"type":"text","value":" , "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"radial"}]},{"type":"text","value":" , "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"dagre"}]},{"type":"text","value":" , 它们通过 Graphin 的 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"props.layout"}]},{"type":"text","value":"来指定具体的布局函数，为 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data.nodes"}]},{"type":"text","value":" 中的节点的添加 x，y 坐标。具体的应用场景详见 "},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/manual/main-concepts/layout"},"children":[{"type":"text","value":"Layout 自动布局"}]},{"type":"text","value":",具体的参数配置详见 "},{"type":"element","tagName":"a","properties":{"href":"/zh/docs/api/layout"},"children":[{"type":"text","value":"Layout API"}]}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/layout/base"},"frontmatter":{"title":"基础布局","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"layout/base/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1 : 常规 Toolbar，Toolbar 是提供分析操作的工具栏。内置了撤销重做（操作历史），画布缩放，全屏，节点聚焦，画布快照下载等等功能。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2 : 自定义 Toolbar，Toolbar 提供了 direction 来控制横向或者纵向显示。我们可以用 render 函数来拓展 Toolbar，使用 render，我们可以给 Toolbar 添加自定义的功能，比如布局切换等等"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/components/toolbar"},"frontmatter":{"title":"Toolbar 工具栏","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"components/toolbar/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"01.风控知识分类"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/case/graph-knowledge"},"frontmatter":{"title":"知识图谱","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"case/graph-knowledge/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://k.sina.cn/article_1655444627_62ac149302000yig1.html?from=local","target":"_self","rel":["nofollow"]},"children":[{"type":"text","value":"《未成年人冒用他人信息注册外卖骑手，发生交通事故谁来担责？》"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/case/identification"},"frontmatter":{"title":"身份识别","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"case/identification/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"金融反欺诈：套现风险"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/case/anti-fraud"},"frontmatter":{"title":"反欺诈","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"case/anti-fraud/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Node Combo"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/advanced/node-combo"},"frontmatter":{"title":"Node Combo","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"advanced/node-combo/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"利用风险聚集原理，由一个风险节点扩散去找其他风险节点。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/advanced/node-expand"},"frontmatter":{"title":"节点扩散","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"advanced/node-expand/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Node Combo"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/advanced/node-combo"},"frontmatter":{"title":"节点分组","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"advanced/node-combo/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"根据六度分割理论，发现可能隐藏的关联关系。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/advanced/find-connections"},"frontmatter":{"title":"关系发现","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"advanced/find-connections/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在图分析应用中，在没有智能推荐布局之前，让用户自主切换布局，是一种比较好的选择。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/advanced/layout-switching"},"frontmatter":{"title":"布局切换","order":0,"icon":null},"parent":{"__typename":"File","relativePath":"advanced/layout-switching/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前 Graphin 内置了 6 种节点"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"节点名称"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"含义"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"SimplicityNode"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"简约节点"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"CircleNode"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"圆形节点"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"RectNode"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"方形节点"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"HexagonNode"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"六边形节点"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"StubNode"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"短线节点"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"PointNode"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"小点节点"}]}]}]}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/shape/node"},"frontmatter":{"title":"内置节点","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"shape/node/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"渲染节点：节点本身携带布局信息(x,y)"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/render/save"},"frontmatter":{"title":"数据有布局信息","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"render/save/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Graphin 内置了 6 款布局，且支持自定义布局"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/layout/force"},"frontmatter":{"title":"力导布局","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"layout/force/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Legend is a common matching component for graph analysis. It usually classifies nodes and edges for dyeing and interactive analysis."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1: highlight logic"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2: filter logic"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/components/legend"},"frontmatter":{"title":"Legend","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"components/legend/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ContextMenu 是一种常用的信息展示交互方式，可以轻松实现节点的复制，删除，反选等等。同时，我们也可以对选择的节点发起新画布分析，或者进行打标，发起关系扩散，数据请求之类的高级自定义行为。这些行为只需要在 MenuItem 的 onClick 回调中实现就可以。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1 : 使用 options 设置右键菜单的内容"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2 : 使用 render 自定义渲染右键菜单"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/components/contextmenu"},"frontmatter":{"title":"ContextMenu 右键菜单","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"components/contextmenu/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Legend 图例是一种常见的图分析配套组件，通常将节点 和 边 分类后进行染色，交互分析。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1 : highlight 逻辑"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2 : filter 逻辑"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/components/legend"},"frontmatter":{"title":"Legend 图例","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"components/legend/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ContextMenu is a common way of information display and interaction, which can easily realize node replication, deletion, deselect, and so on. At the same time, we can also initiate a new canvas analysis on the selected node, or perform advanced custom behaviors such as marking, initiating relationship diffusion, and data request. These behaviors only need to be implemented in the onClick callback of MenuItem."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1: Use options to set the content of the right-click menu"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2: Use render to customize the rendering right-click menu"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/components/contextmenu"},"frontmatter":{"title":"ContextMenu","order":1,"icon":null},"parent":{"__typename":"File","relativePath":"components/contextmenu/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前 Graphin 支持多边，通过设置 options.autoPolyEdge = true 开启"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/shape/edge"},"frontmatter":{"title":"多边","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"shape/edge/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"增量数据渲染"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"关系分析：添加节点"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"关系分析：节点扩散"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/render/expand"},"frontmatter":{"title":"增量数据渲染","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"render/expand/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/layout/sublayout"},"frontmatter":{"title":"子图布局","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"layout/sublayout/index.zh.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In time series analysis, the timeline is essential. The design of Timebar timeline in Graphin's design specification is still in progress. Here, we provide a demo to illustrate the basic implementation idea."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1: simple self-implementation of Timebar"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2: The graphin-components built-in Timebar is being developed..."}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/en/examples/components/timebar"},"frontmatter":{"title":"Timebar","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"components/timebar/index.en.md"}}},{"node":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在时序分析中，时间轴必不可少，Graphin 的设计规范里针对 Timebar 时间轴的设计还在进行中，我们这里通过提供一个 demo，来说明基本实现思路"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-1 : 简单自实现 Timebar"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"demo-2 : 官方内置 Timebar，正在开发中..."}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"fields":{"slug":"/zh/examples/components/timebar"},"frontmatter":{"title":"Timebar 时间轴","order":2,"icon":null},"parent":{"__typename":"File","relativePath":"components/timebar/index.zh.md"}}}]}},"pageContext":{"exampleSections":{"examples":[{"relativePath":"advanced/find-connections/demo/Simple.jsx","absolutePath":"/Users/pomelo/Desktop/github/graphin-1.x/packages/graphin-site/examples/advanced/find-connections/demo/Simple.jsx","order":0,"filename":"Simple.jsx","title":"关系发现","screenshot":"","source":"/* eslint-disable no-undef */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Graphin, { Utils } from '@antv/graphin';\nimport { Toolbar } from '@antv/graphin-components';\nimport { message } from 'antd';\nimport '@antv/graphin/dist/index.css'; // 引入Graphin CSS\nimport '@antv/graphin-components/dist/index.css'; // 引入Graphin CSS\n\nconst chunk = (arr, size) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));\n\nconst App = () => {\n  const [state, setState] = React.useState({\n    selected: [],\n    data: Utils.mock(20)\n      .random()\n      .graphin(),\n  });\n\n  const { data, selected } = state;\n  const graphRef = React.createRef(null);\n  React.useEffect(() => {\n    const { graph } = graphRef.current;\n    const onNodeSelectChange = e => {\n      const nodes = e.selectedItems.nodes.map(node => {\n        return node.get('model');\n      });\n      setState({\n        ...state,\n        selected: nodes,\n      });\n    };\n    graph.on('nodeselectchange', onNodeSelectChange);\n\n    return () => {\n      graph.off('nodeselectchange', onNodeSelectChange);\n    };\n  }, [state]);\n\n  const onFindConnections = () => {\n    if (selected.length === 0) {\n      message.info('请先选中/圈选节点');\n      return;\n    }\n\n    const findConnectionData = { nodes: [], edges: [] };\n    // 1度扩散，中间经历一个节点\n    const sortArray = chunk(selected, 2);\n    sortArray.forEach(arr => {\n      const [source, target = selected[0]] = arr;\n\n      const relativeNode = {\n        id: `find-node-${source.id}-${target.id}`,\n        shape: 'CircleNode',\n        label: 'discover node',\n        style: {\n          primaryColor: '#ff7617',\n          icon: 'home',\n          nodeSize: 20,\n        },\n        data: {\n          id: `find-node-${source.id}-${target.id}`,\n        },\n      };\n      findConnectionData.nodes.push(...arr, relativeNode);\n      findConnectionData.edges.push(\n        {\n          source: source.id,\n          target: relativeNode.id,\n          shape: 'LineEdge',\n          label: '一度发现',\n          style: {\n            line: {\n              dash: [2, 2],\n            },\n          },\n          data: {\n            source: source.id,\n            target: relativeNode.id,\n          },\n        },\n        {\n          source: relativeNode.id,\n          target: target.id,\n          shape: 'LineEdge',\n          label: '一度发现',\n          style: {\n            line: {\n              dash: [2, 2],\n            },\n          },\n          data: {\n            source: relativeNode.id,\n            target: target.id,\n          },\n        },\n      );\n    });\n\n    setState({\n      ...state,\n      data: {\n        // 还需要对Node和Edge去重，这里暂不考虑\n        nodes: [...state.data.nodes, ...findConnectionData.nodes],\n        edges: [...state.data.edges, ...findConnectionData.edges],\n      },\n    });\n  };\n\n  return (\n    <div className=\"App\">\n      <h3>\n        基于力导的关系发现：按住Shift圈选你需要发现关系的节点\n        <button\n          type=\"submit\"\n          onClick={onFindConnections}\n          style={{ float: 'right', height: '28px', lineHeight: '28px' }}\n        >\n          点击发现关系\n        </button>\n      </h3>\n      <Graphin\n        data={data}\n        layout={{\n          name: 'force',\n          options: {\n            defSpringLen: (_edge, source, target) => {\n              /** 默认返回的是 200 的弹簧长度 */\n              /** 如果你要想要产生聚类的效果，可以考虑 根据边两边节点的度数来动态设置边的初始化长度：度数越小，则边越短 */\n              const nodeSize = 30;\n              const Sdegree = source.data.layout?.degree;\n              const Tdegree = target.data.layout?.degree;\n              const minDegree = Math.min(Sdegree, Tdegree);\n              return minDegree < 3 ? nodeSize * 5 : minDegree * nodeSize * 2;\n            },\n          },\n        }}\n        ref={graphRef}\n      >\n        <Toolbar style={{ position: 'absolute', bottom: 28, left: 28 }} />\n      </Graphin>\n    </div>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById('container'));\n","babeledSource":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"react\", \"react-dom\", \"@antv/graphin\", \"@antv/graphin-components\", \"antd\", \"@antv/graphin/dist/index.css\", \"@antv/graphin-components/dist/index.css\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"react\"), require(\"react-dom\"), require(\"@antv/graphin\"), require(\"@antv/graphin-components\"), require(\"antd\"), require(\"@antv/graphin/dist/index.css\"), require(\"@antv/graphin-components/dist/index.css\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global.react, global.reactDom, global.graphin, global.graphinComponents, global.antd, global.index, global.index);\n    global.Simple = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_react, _reactDom, _graphin, _graphinComponents, _antd, _index, _index2) {\n  \"use strict\";\n\n  _react = _interopRequireDefault(_react);\n  _reactDom = _interopRequireDefault(_reactDom);\n  _graphin = _interopRequireWildcard(_graphin);\n\n  function _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\n  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\n  function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\n  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\n  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\n  function _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\n  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n  // 引入Graphin CSS\n  var chunk = function chunk(arr, size) {\n    return Array.from({\n      length: Math.ceil(arr.length / size)\n    }, function (v, i) {\n      return arr.slice(i * size, i * size + size);\n    });\n  };\n\n  var App = function App() {\n    var _React$useState = _react.default.useState({\n      selected: [],\n      data: _graphin.Utils.mock(20).random().graphin()\n    }),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        state = _React$useState2[0],\n        setState = _React$useState2[1];\n\n    var data = state.data,\n        selected = state.selected;\n\n    var graphRef = /*#__PURE__*/_react.default.createRef(null);\n\n    _react.default.useEffect(function () {\n      var graph = graphRef.current.graph;\n\n      var onNodeSelectChange = function onNodeSelectChange(e) {\n        var nodes = e.selectedItems.nodes.map(function (node) {\n          return node.get('model');\n        });\n        setState({ ...state,\n          selected: nodes\n        });\n      };\n\n      graph.on('nodeselectchange', onNodeSelectChange);\n      return function () {\n        graph.off('nodeselectchange', onNodeSelectChange);\n      };\n    }, [state]);\n\n    var onFindConnections = function onFindConnections() {\n      if (selected.length === 0) {\n        _antd.message.info('请先选中/圈选节点');\n\n        return;\n      }\n\n      var findConnectionData = {\n        nodes: [],\n        edges: []\n      }; // 1度扩散，中间经历一个节点\n\n      var sortArray = chunk(selected, 2);\n      sortArray.forEach(function (arr) {\n        var _findConnectionData$n;\n\n        var _arr2 = _slicedToArray(arr, 2),\n            source = _arr2[0],\n            _arr2$ = _arr2[1],\n            target = _arr2$ === void 0 ? selected[0] : _arr2$;\n\n        var relativeNode = {\n          id: \"find-node-\".concat(source.id, \"-\").concat(target.id),\n          shape: 'CircleNode',\n          label: 'discover node',\n          style: {\n            primaryColor: '#ff7617',\n            icon: 'home',\n            nodeSize: 20\n          },\n          data: {\n            id: \"find-node-\".concat(source.id, \"-\").concat(target.id)\n          }\n        };\n\n        (_findConnectionData$n = findConnectionData.nodes).push.apply(_findConnectionData$n, _toConsumableArray(arr).concat([relativeNode]));\n\n        findConnectionData.edges.push({\n          source: source.id,\n          target: relativeNode.id,\n          shape: 'LineEdge',\n          label: '一度发现',\n          style: {\n            line: {\n              dash: [2, 2]\n            }\n          },\n          data: {\n            source: source.id,\n            target: relativeNode.id\n          }\n        }, {\n          source: relativeNode.id,\n          target: target.id,\n          shape: 'LineEdge',\n          label: '一度发现',\n          style: {\n            line: {\n              dash: [2, 2]\n            }\n          },\n          data: {\n            source: relativeNode.id,\n            target: target.id\n          }\n        });\n      });\n      setState({ ...state,\n        data: {\n          // 还需要对Node和Edge去重，这里暂不考虑\n          nodes: [].concat(_toConsumableArray(state.data.nodes), _toConsumableArray(findConnectionData.nodes)),\n          edges: [].concat(_toConsumableArray(state.data.edges), _toConsumableArray(findConnectionData.edges))\n        }\n      });\n    };\n\n    return /*#__PURE__*/_react.default.createElement(\"div\", {\n      className: \"App\"\n    }, /*#__PURE__*/_react.default.createElement(\"h3\", null, \"\\u57FA\\u4E8E\\u529B\\u5BFC\\u7684\\u5173\\u7CFB\\u53D1\\u73B0\\uFF1A\\u6309\\u4F4FShift\\u5708\\u9009\\u4F60\\u9700\\u8981\\u53D1\\u73B0\\u5173\\u7CFB\\u7684\\u8282\\u70B9\", /*#__PURE__*/_react.default.createElement(\"button\", {\n      type: \"submit\",\n      onClick: onFindConnections,\n      style: {\n        float: 'right',\n        height: '28px',\n        lineHeight: '28px'\n      }\n    }, \"\\u70B9\\u51FB\\u53D1\\u73B0\\u5173\\u7CFB\")), /*#__PURE__*/_react.default.createElement(_graphin.default, {\n      data: data,\n      layout: {\n        name: 'force',\n        options: {\n          defSpringLen: function defSpringLen(_edge, source, target) {\n            var _source$data$layout, _target$data$layout;\n\n            /** 默认返回的是 200 的弹簧长度 */\n\n            /** 如果你要想要产生聚类的效果，可以考虑 根据边两边节点的度数来动态设置边的初始化长度：度数越小，则边越短 */\n            var nodeSize = 30;\n            var Sdegree = (_source$data$layout = source.data.layout) === null || _source$data$layout === void 0 ? void 0 : _source$data$layout.degree;\n            var Tdegree = (_target$data$layout = target.data.layout) === null || _target$data$layout === void 0 ? void 0 : _target$data$layout.degree;\n            var minDegree = Math.min(Sdegree, Tdegree);\n            return minDegree < 3 ? nodeSize * 5 : minDegree * nodeSize * 2;\n          }\n        }\n      },\n      ref: graphRef\n    }, /*#__PURE__*/_react.default.createElement(_graphinComponents.Toolbar, {\n      style: {\n        position: 'absolute',\n        bottom: 28,\n        left: 28\n      }\n    })));\n  };\n\n  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(App, null), document.getElementById('container'));\n});"}]}}},"staticQueryHashes":["1015175297","3000541721","3000541721","653731124"]}